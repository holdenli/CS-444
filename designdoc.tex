% Instructions:
% Claim the sections you want to write up by putting your name under the
% subsection.
% I will fill in anything that's missing/unclaimed.
% Don't worry about syntax/format - you can copypaste from Word/GDoc if you
% want. I'll deal with the formatting when we have the points in.

\documentclass[12pt]{article}
\usepackage{designdoc}

\begin{document}

\begin{center}
  \textbf{\Large{CS 444: Assignment 4 Design}} \\
  \vspace{5pt}
  Vardhan Mudunuru (vmudunur), Holden Li (h55li), Charlie Mei (cmei) \\
\end{center}
\vspace{5pt}

\section*{Introduction}

This document outlines the design and implementation of semantic and
context-sensitive analysis for the Joosc compiler. We first describe the main
design changes with respect to the previous design, such as testing and
executable changes. Following that, we outline the additional stages of
compilation that are implemented for assignments 2 through 4, in addition to
providing implementation details for each stage. The additional stages are
described (and grouped) in order of the original assignment submissions.

\section{Changes from initial design}

\subsection{Program execution and options}
cmei

\subsection{Testing}
cmei
remember parallelism

\section{Assignment 2 design}

\subsection{Abstract syntax tree}
cmei

\subsection{Environment building}
In this stage, the ASTs are fed in and an environment tree is built for each
one.  An environment tree provides scoping information for each type
(class/interface), where each node in the tree contains the
symbols (variables, fields or methods)
declared in that scope.

Each environment node is named after the AST node that it describes.  The root
environment node is the CompilationUnit;  its children are TypeImports,
PackageDeclaration, and ClassDeclaration.  The TypeImports and
PackageDeclaration are a not scope, but they were included for
convinience when determining the canonical name of the type.

The ClassDeclaration environment contains all the fields and methods that are
declared in it.
The children of the ClassDeclaration environment are the MethodDeclaration or
ConstructorDeclaration environment nodes.  These declaration nodes contain
parameters declared in the method or constructor.  The declaration environment
nodes have children that are Block environments (and their children as well,
which are recursively explored) contains all the local variables declared under
that AST block node.

These block nodes are built by exploring each statement in the body in-order, one at a
time, as opposed to just search for LocalVariableDeclaration AST nodes.  This
was necessary so that variables are only made available at the time of their
declaration in that block, so earlier statements cannot reference them.

\subsection{Type linking}
This stage does two things:  First, it builds an index of canonical type names
mapping to their CompilationUnit environment.  Then, it finds Type nodes in the
AST, and annotates them with the canonical type name it refers to.

In order to build the index, we simply go through each AST, figure out the
package name (located in the PackageDeclaration node, but defaults to package
'MAIN_PKG' if one does not exist), its type name (The name from the
ClassDeclaration or InterfaceDeclaration node).  Putting the two together gives
us the canonical type name.

In order to annotate all the Type nodes, the context in which it is used is not
required;  we simply look for Type nodes in each AST and try to derive the
canonical type for it.  We try possible canonical names for the type in a
particular order:  Is it a type in the same package?  Is it one of the imported
types in the compilation unit, or Is it an ondemand package?  If we fail to
resolve the canonical name for that type after trying these 3 possibilities,
then the type does not exist.

The above procedure does not apply to primitive types.  The Type nodes for these
are labelled as their primitive equivalent and are handled differently from
reference types.
For array types, we simply append a '[]' to the canonical type
we resolve it to.

At this point, all Type nodes have been annotated with their fully qualified
canonical names.

\subsection{Class hierarchy}
This stage introduces a new representation of Classes/Interfaces,
Methods/Constructors, and Fields and links the declaration of each in the AST
with an instance of these objects. The object representation of contain
any useful information on these objects in an easy to access way (ie.
the Class object has a declare set and inherit set)

Equality has been defined for Methods as
comparing signatures and defined for fields as name. This allows for operations
on these objects and sets of objects to make sense in this context.

Each declaration in the AST is linked to their respective object and vice versa
for convenience in the future. But also an index (dictionary) of all available Classes
is generated with the fully qualified name as the key.

The process of generating these objects, the index, and checking the
class hierarchy are all done together. 
The process happens in 6 stages:

1. Scanning ASTs for classes and creating the dictionary
    - Setups the Class object with basic information.
    - Uses type link information to figure out who to extend/implement.
2. Use the dictionary to create hierarchy
    - Link a Class' extend/implement with the right Class object; this creates
    an upside down tree structure for the hierarchy.
3. Check for cycles
    - Simply going through every Class and going up the hierarchy
    until we reach an end or a cycle.
4. Create Method and Field objects and fill in Declare set
    - Check the declarations in the classes and fill the Declare set
    with their object representations.
    - Add special delcarations (ie. interface's implicit methods from Object)
5. Fill Inherit set
    - Simply keep trying to fill in inherit data until everything is filled in.
    - Most complicated stage due to checking for hiding/overriding.
    - No infinite loop due to cycle checking.
6. Final checks
    - Any other checks that don't fit the other stages happen here.
    - ie. implicit default constructor.

\section{Assignment 3 design}

\subsection{Name disambiguation and resolution}

In this stage, we find all 'Name' nodes from our AST, and resolve them to a
local variable or field declaration they refer to -- names are not resolved to method
declarations until after type checking, as the parameters themselves are expressions
that need to be resolved to a type. After these Name nodes have been
disambiguated, they are linked to the declaration node they refer to. This part
of the compiler uses utility functions created in the Class Heirarchy phase,
notably the function that returns the contain set (of methods and fields) given
a fully canonical type.

First, the field initializers are resolved;  In order to deal with forward
referencing, we pass around a 'blacklist' of simple names that, when resolved to,
should throw out a Illegal Forward Reference error. Then, we go through each
method's body, statement by statement, picking up variables as they are declared
and recursing into Block nodes (which are also seen during if/else, while, and
for statements).  For each statement, we try to find, disambiguate and resolve
all Name nodes seen in the statements.

There are two functions that contain the logic for disambiguation and name
resolution:  one iterates through expressions finding Name nodes,
and the other is for disambiguating a name and linking it to its declaration.  The first
function looks for Name, MethodInvocation, FieldAccess and ArrayAccess and
Assignment nodes.  Only the
method receiver and arguments are recursively name-resolved (i.e, we recurse
into them).  The method invocations need to be type checked before we can
determine which method it is.  Further, we name resolve the FieldReceiver node
recursively, but the FieldAccess itself is not resolved until it is fully
typechecked.

Assignment expressions also recursively resolved on both the left and
right-hand-side, but the right-hand-side is passed in a 'blacklist' of simple
names that are not allowed to be resolved.  This is used to implement forward
referencing in fields initializers.

The second function involves disambiguating a name.  This function takes the
type that we are disambiguate from (so that we can use this type's contain set),
the name, a blacklist of simple names that can't be reference, and
a flag indicating if the name is in a static context.  First, simple names are
checked if they are in the blacklist.  A corner case is if
the name could be resolved to a array length expression;  in which case, this is
not technically a simple name, but should still be checked in the blacklist.

It then checks if the left most part of the name is a local variable, or if it
is in the contain set.  If true, then we find the type that this first part
resolves to, and recurse into the rest of the name under this type's context;
we do not pass on the black list or local variables.

Before we recurse, we must also check that we can recurse into the second part
of the name, if it exists; this involves access checking.  If the second part of
the name might resolve to a protected field that we don't have access to, we
must abort.  Additionally, we do not recurse if the first part resolves to an
array -- in which case, the rest of the name, if it exists, must be '.length'.

\subsection{Type checking}
ADD MORE DETAILS HERE CMEI!

Type check with rules for each expression or primary implemented as a function.
Also type check the boolean in if/while/for statements.

A general function that can be called on any node that can be type checked.
It then determines the right 'rule' to apply and call the appropriate function.
The function itself might need to type check an expression and it would
call that the general type check function (recursion). Once an expression has been
type checked, the type is added to the AST node (allows memoization and convenience
for the future).

To make sure we type check everything, type check is run on all 'typecheckable'
nodes found in a tree. Instead of traversing it normally. Memoization makes this
not terribe.

\section{Assignment 4 design}

\subsection{Reachability analysis}
Three flags are added to statement nodes:

reachable - "this statement >>is<< reachable" -
    True if statement is reachable. None if it hasn't been determined.
    It cannot be False because compiler will exit by then.

can complete - "this statement >>can<< complete" -
    True if the statement can complete. False otherwise.

will end - "this statement >>will<< end with return statement" -
    This is True when it is a return statement
    or a statement that contains return statements in all possible
    executions.
    And it is False if the statement does not end method execution.
    It is None if the statement is infinite.

The check that all statements must be reachable and that methods must end with
a return statement is done together.
The analysis begins by finding every constructor or method in each class.
Then it runs a reachability check on the block statement.
This is a recursive check that checks any statement and determines if it is
'reachable', 'can_complete', and 'will_end'.
The program terminates if something is deemed
unreachable. And on completion of the check on the method body, the 'will_end'
flag is checked to ensure that a return statement ends the block.

This check relies on evaluating constant expressions which is done by scanning expression
nodes in the AST and determining their values as the computed value or None
(which represents 'Do Not Know'). Any literal encountered in this scan will return their
values and anything else will return None.

\subsection{Variable initialization analysis}

\end{document}
